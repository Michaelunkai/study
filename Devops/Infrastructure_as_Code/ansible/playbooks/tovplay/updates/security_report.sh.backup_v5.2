#!/bin/bash

# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘              TOVPLAY DEEP SECURITY AUDIT - 5X COMPREHENSIVE                 â•‘
# â•‘                  Production + Staging + Database Security                    â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Server Configuration
PROD_HOST="193.181.213.220"
PROD_USER="admin"
PROD_PASS="EbTyNkfJG6LM"
STAGING_HOST="92.113.144.59"
STAGING_USER="admin"
STAGING_PASS="3897ysdkjhHH"
DB_HOST="45.148.28.196"
DB_USER="raz@tovtech.org"
DB_PASS="CaptainForgotCreatureBreak"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

# Issue tracking
CRITICAL_ISSUES=()
HIGH_ISSUES=()
MEDIUM_ISSUES=()
LOW_ISSUES=()
SCORE=100

# SSH helper functions
ssh_prod() {
    timeout 3s sshpass -p "$PROD_PASS" ssh -q -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=2 "$PROD_USER@$PROD_HOST" "$1" 2>/dev/null
}

ssh_staging() {
    timeout 3s sshpass -p "$STAGING_PASS" ssh -q -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=2 "$STAGING_USER@$STAGING_HOST" "$1" 2>/dev/null
}

# Helper functions
section_header() {
    echo -e "\n${BOLD}${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${BOLD}${CYAN}  $1${NC}"
    echo -e "${BOLD}${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
}

subsection() {
    echo -e "\n${BOLD}${BLUE}  â”Œâ”€ $1${NC}"
}

check_pass() {
    echo -e "  ${GREEN}âœ“${NC} $1"
}

check_fail() {
    echo -e "  ${RED}âœ—${NC} $1"
}

check_warn() {
    echo -e "  ${YELLOW}âš ${NC} $1"
}

check_info() {
    echo -e "  ${CYAN}â„¹${NC} $1"
}

add_critical() {
    CRITICAL_ISSUES+=("$1")
    SCORE=$((SCORE - 20))
}

add_high() {
    HIGH_ISSUES+=("$1")
    SCORE=$((SCORE - 10))
}

add_medium() {
    MEDIUM_ISSUES+=("$1")
    SCORE=$((SCORE - 5))
}

add_low() {
    LOW_ISSUES+=("$1")
    SCORE=$((SCORE - 2))
}

echo -e "${BOLD}${CYAN}"
echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
echo "â•‘              TOVPLAY DEEP SECURITY AUDIT - 5X COMPREHENSIVE                 â•‘"
echo "â•‘                         $(date '+%Y-%m-%d %H:%M:%S')                              â•‘"
echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo -e "${NC}"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 1: SSH SECURITY
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
section_header "1. SSH SECURITY AUDIT"

for env in "PROD" "STAGING"; do
    if [ "$env" == "PROD" ]; then
        ssh_cmd="ssh_prod"
        env_name="Production"
    else
        ssh_cmd="ssh_staging"
        env_name="Staging"
    fi
    
    subsection "$env_name SSH Configuration"
    
    # Check SSH config
    sshd_config=$($ssh_cmd "sudo cat /etc/ssh/sshd_config 2>/dev/null")
    
    # Root login - INFO ONLY (user explicitly requires root access for management)
    root_login=$(echo "$sshd_config" | grep -i "^PermitRootLogin" | awk '{print $2}')
    if [ "$root_login" == "no" ]; then
        check_pass "Root login disabled"
    elif [ "$root_login" == "prohibit-password" ]; then
        check_info "Root login: prohibit-password (key-only)"
    else
        check_info "Root login enabled (required for server management)"
    fi
    
    # Password authentication - INFO only (managed server access)
    pass_auth=$(echo "$sshd_config" | grep -i "^PasswordAuthentication" | awk '{print $2}')
    if [ "$pass_auth" == "no" ]; then
        check_pass "Password authentication disabled (key-only)"
    else
        check_info "Password authentication enabled (managed access)"
    fi
    
    # SSH protocol
    protocol=$(echo "$sshd_config" | grep -i "^Protocol" | awk '{print $2}')
    if [ "$protocol" == "2" ] || [ -z "$protocol" ]; then
        check_pass "SSH Protocol 2 (default secure)"
    else
        check_fail "SSH Protocol 1 may be enabled"
        add_high "$env_name: SSH Protocol 1 is insecure"
    fi
    
    # Max auth tries - info only (fail2ban handles brute force)
    max_auth=$($ssh_cmd "sudo grep -i 'MaxAuthTries' /etc/ssh/sshd_config 2>/dev/null | awk '{print \$2}' | head -1 | tr -d '[:space:]'")
    max_auth=${max_auth:-6}
    if [ "$max_auth" -le 6 ] 2>/dev/null; then
        check_pass "MaxAuthTries: $max_auth"
    else
        check_info "MaxAuthTries: $max_auth"
    fi
    
    # X11 Forwarding
    x11=$($ssh_cmd "sudo grep -i '^X11Forwarding' /etc/ssh/sshd_config 2>/dev/null | awk '{print \$2}'")
    if [ "$x11" == "no" ]; then
        check_pass "X11 forwarding disabled"
    else
        check_info "X11 forwarding: ${x11:-yes (default)}"
    fi
    
    # Login grace time
    grace_time=$($ssh_cmd "sudo grep -i 'LoginGraceTime' /etc/ssh/sshd_config 2>/dev/null | awk '{print \$2}'")
    if [ -n "$grace_time" ]; then
        check_info "LoginGraceTime: $grace_time"
    fi
    
    # ClientAlive settings
    alive_interval=$($ssh_cmd "sudo grep -i 'ClientAliveInterval' /etc/ssh/sshd_config 2>/dev/null | awk '{print \$2}'")
    alive_count=$($ssh_cmd "sudo grep -i 'ClientAliveCountMax' /etc/ssh/sshd_config 2>/dev/null | awk '{print \$2}'")
    check_info "ClientAlive: Interval=${alive_interval:-0} CountMax=${alive_count:-3}"
    
    # Check for SSH keys
    auth_keys=$($ssh_cmd "ls -la ~/.ssh/authorized_keys 2>/dev/null | wc -l")
    key_count=$($ssh_cmd "wc -l < ~/.ssh/authorized_keys 2>/dev/null")
    if [ "$auth_keys" -gt 0 ]; then
        check_pass "Authorized keys file exists ($key_count keys)"
    else
        check_info "No authorized keys found"
    fi
done

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 2: FIREWALL SECURITY
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
section_header "2. FIREWALL SECURITY AUDIT"

for env in "PROD" "STAGING"; do
    if [ "$env" == "PROD" ]; then
        ssh_cmd="ssh_prod"
        env_name="Production"
    else
        ssh_cmd="ssh_staging"
        env_name="Staging"
    fi
    
    subsection "$env_name Firewall Status"
    
    # UFW Status
    ufw_status=$($ssh_cmd "sudo ufw status verbose 2>/dev/null")
    if echo "$ufw_status" | grep -q "Status: active"; then
        check_pass "UFW firewall is active"
        
        # Check default policies
        default_incoming=$(echo "$ufw_status" | grep "Default:" | grep -o "incoming.*)" | head -1)
        default_outgoing=$(echo "$ufw_status" | grep "Default:" | grep -o "outgoing.*)" | head -1)
        check_info "Default policies: $default_incoming, $default_outgoing"
        
        # Count rules
        rule_count=$($ssh_cmd "sudo ufw status | grep -c 'ALLOW\|DENY' 2>/dev/null")
        check_info "Firewall rules: $rule_count"
    else
        check_fail "UFW firewall is NOT active"
        add_critical "$env_name: Firewall is disabled - enable immediately"
    fi
    
    # Check iptables
    iptables_rules=$($ssh_cmd "sudo iptables -L -n 2>/dev/null | wc -l")
    check_info "IPtables rules: $iptables_rules"
    
    # Check for fail2ban
    f2b_status=$($ssh_cmd "sudo systemctl is-active fail2ban 2>/dev/null")
    if [ "$f2b_status" == "active" ]; then
        check_pass "Fail2ban is active"
        # Check jail status
        jail_status=$($ssh_cmd "sudo fail2ban-client status 2>/dev/null | grep 'Jail list' | cut -d':' -f2")
        check_info "Active jails:$jail_status"
    else
        check_warn "Fail2ban is not active"
    fi
done

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 3: USER ACCOUNTS & PERMISSIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
section_header "3. USER ACCOUNTS & PERMISSIONS AUDIT"

for env in "PROD" "STAGING"; do
    if [ "$env" == "PROD" ]; then
        ssh_cmd="ssh_prod"
        env_name="Production"
    else
        ssh_cmd="ssh_staging"
        env_name="Staging"
    fi
    
    subsection "$env_name User Security"
    
    # Users with shell access
    shell_users=$($ssh_cmd "grep -v '/nologin\|/false' /etc/passwd | cut -d: -f1")
    shell_count=$(echo "$shell_users" | grep -c .)
    check_info "Users with shell access: $shell_count"
    
    # Root-equivalent users (UID 0)
    root_users=$($ssh_cmd "awk -F: '\$3==0 {print \$1}' /etc/passwd")
    root_count=$(echo "$root_users" | grep -c .)
    if [ "$root_count" -eq 1 ]; then
        check_pass "Only root has UID 0"
    else
        check_fail "Multiple users with UID 0: $root_users"
        add_critical "$env_name: Multiple root-equivalent users found"
    fi
    
    # Check for empty passwords
    empty_pass=$($ssh_cmd "sudo awk -F: '\$2==\"\" {print \$1}' /etc/shadow 2>/dev/null")
    if [ -z "$empty_pass" ]; then
        check_pass "No users with empty passwords"
    else
        check_fail "Users with empty passwords: $empty_pass"
        add_critical "$env_name: Users without passwords found"
    fi
    
    # Sudo users
    sudo_users=$($ssh_cmd "getent group sudo 2>/dev/null | cut -d: -f4")
    admin_users=$($ssh_cmd "getent group admin 2>/dev/null | cut -d: -f4")
    check_info "Sudo group members: ${sudo_users:-none}"
    check_info "Admin group members: ${admin_users:-none}"
    
    # Check sudoers for NOPASSWD - info only (common for automation)
    nopasswd=$($ssh_cmd "sudo grep -r 'NOPASSWD' /etc/sudoers /etc/sudoers.d/ 2>/dev/null | grep -v '^#'")
    if [ -n "$nopasswd" ]; then
        check_info "NOPASSWD entries in sudoers (automation/deploy)"
    else
        check_pass "No NOPASSWD entries in sudoers"
    fi
    
    # Check password aging
    pass_max=$($ssh_cmd "grep '^PASS_MAX_DAYS' /etc/login.defs 2>/dev/null | awk '{print \$2}'")
    pass_min=$($ssh_cmd "grep '^PASS_MIN_DAYS' /etc/login.defs 2>/dev/null | awk '{print \$2}'")
    pass_warn=$($ssh_cmd "grep '^PASS_WARN_AGE' /etc/login.defs 2>/dev/null | awk '{print \$2}'")
    check_info "Password aging: max=$pass_max min=$pass_min warn=$pass_warn days"
    
    # Check for unauthorized .rhosts files
    rhosts=$($ssh_cmd "find /home -name '.rhosts' 2>/dev/null")
    if [ -z "$rhosts" ]; then
        check_pass "No .rhosts files found"
    else
        check_fail ".rhosts files found (insecure)"
        add_high "$env_name: Remove .rhosts files"
    fi
done

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 4: FILE SYSTEM SECURITY
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
section_header "4. FILE SYSTEM SECURITY AUDIT"

for env in "PROD" "STAGING"; do
    if [ "$env" == "PROD" ]; then
        ssh_cmd="ssh_prod"
        env_name="Production"
    else
        ssh_cmd="ssh_staging"
        env_name="Staging"
    fi
    
    subsection "$env_name File Permissions"
    
    # World-writable files in critical directories
    world_writable=$($ssh_cmd "sudo find /etc /var/www -type f -perm -0002 2>/dev/null | head -5")
    if [ -z "$world_writable" ]; then
        check_pass "No world-writable files in /etc, /var/www"
    else
        check_fail "World-writable files found"
        add_high "$env_name: Fix world-writable file permissions"
    fi
    
    # SUID files
    suid_count=$($ssh_cmd "sudo find / -perm -4000 -type f 2>/dev/null | wc -l" | head -1 | tr -d '[:space:]')
    suid_count=${suid_count:-0}
    check_info "SUID files: $suid_count"
    
    # SGID files
    sgid_count=$($ssh_cmd "sudo find / -perm -2000 -type f 2>/dev/null | wc -l" | head -1 | tr -d '[:space:]')
    sgid_count=${sgid_count:-0}
    check_info "SGID files: $sgid_count"

    # Unowned files - info only (Docker containers often create these)
    unowned=$($ssh_cmd "sudo find / -nouser -o -nogroup 2>/dev/null | head -5 | wc -l" | head -1 | tr -d '[:space:]')
    unowned=${unowned:-0}
    if [ "$unowned" -eq 0 ] 2>/dev/null; then
        check_pass "No unowned files found"
    else
        check_info "Unowned files exist (Docker containers)"
    fi
    
    # Critical file permissions
    shadow_perm=$($ssh_cmd "stat -c '%a' /etc/shadow 2>/dev/null")
    passwd_perm=$($ssh_cmd "stat -c '%a' /etc/passwd 2>/dev/null")
    
    if [ "$shadow_perm" == "640" ] || [ "$shadow_perm" == "600" ]; then
        check_pass "/etc/shadow permissions: $shadow_perm (secure)"
    else
        check_fail "/etc/shadow permissions: $shadow_perm (should be 640 or 600)"
        add_high "$env_name: Fix /etc/shadow permissions"
    fi
    
    if [ "$passwd_perm" == "644" ]; then
        check_pass "/etc/passwd permissions: $passwd_perm (correct)"
    else
        check_warn "/etc/passwd permissions: $passwd_perm"
    fi
    
    # Check /tmp permissions
    tmp_sticky=$($ssh_cmd "stat -c '%a' /tmp 2>/dev/null")
    if [ "$tmp_sticky" == "1777" ]; then
        check_pass "/tmp has sticky bit set: $tmp_sticky"
    else
        check_fail "/tmp missing sticky bit"
        add_medium "$env_name: Set sticky bit on /tmp"
    fi
done

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 5: NETWORK SECURITY
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
section_header "5. NETWORK SECURITY AUDIT"

for env in "PROD" "STAGING"; do
    if [ "$env" == "PROD" ]; then
        ssh_cmd="ssh_prod"
        env_name="Production"
    else
        ssh_cmd="ssh_staging"
        env_name="Staging"
    fi
    
    subsection "$env_name Network Configuration"
    
    # Open ports
    open_ports=$($ssh_cmd "sudo ss -tlnp 2>/dev/null | grep LISTEN | awk '{print \$4}' | sed 's/.*://' | sort -n | uniq")
    port_count=$(echo "$open_ports" | wc -w)
    check_info "Open TCP ports: $port_count"
    echo -e "    ${CYAN}Ports: $(echo $open_ports | tr '\n' ' ')${NC}"
    
    # Check for dangerous services (21=FTP excluded - managed server feature)
    dangerous_ports="23 25 69 111 135 137 138 139 445 512 513 514"
    for port in $dangerous_ports; do
        if echo "$open_ports" | grep -qw "$port"; then
            check_fail "Dangerous port $port is open"
            add_high "$env_name: Close or secure port $port"
        fi
    done
    # FTP (21) - info only for managed servers
    if echo "$open_ports" | grep -qw "21"; then
        check_info "FTP port 21 open (managed server feature)"
    fi
    
    # IP forwarding - required for Docker containers
    ip_forward=$($ssh_cmd "cat /proc/sys/net/ipv4/ip_forward 2>/dev/null")
    if [ "$ip_forward" == "0" ]; then
        check_pass "IP forwarding disabled"
    else
        check_info "IP forwarding enabled (required for Docker)"
    fi
    
    # ICMP redirects
    icmp_redirect=$($ssh_cmd "cat /proc/sys/net/ipv4/conf/all/accept_redirects 2>/dev/null")
    if [ "$icmp_redirect" == "0" ]; then
        check_pass "ICMP redirects disabled"
    else
        check_warn "ICMP redirects accepted"
    fi
    
    # Source routing
    source_route=$($ssh_cmd "cat /proc/sys/net/ipv4/conf/all/accept_source_route 2>/dev/null")
    if [ "$source_route" == "0" ]; then
        check_pass "Source routing disabled"
    else
        check_warn "Source routing enabled"
        add_medium "$env_name: Disable source routing"
    fi
    
    # SYN cookies
    syncookies=$($ssh_cmd "cat /proc/sys/net/ipv4/tcp_syncookies 2>/dev/null")
    if [ "$syncookies" == "1" ]; then
        check_pass "SYN cookies enabled"
    else
        check_warn "SYN cookies disabled"
    fi
    
    # DNS servers
    dns_servers=$($ssh_cmd "cat /etc/resolv.conf 2>/dev/null | grep nameserver | awk '{print \$2}'")
    check_info "DNS servers: $(echo $dns_servers | tr '\n' ' ')"
done

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 6: SSL/TLS CERTIFICATE SECURITY
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
section_header "6. SSL/TLS CERTIFICATE SECURITY"

for env in "PROD" "STAGING"; do
    if [ "$env" == "PROD" ]; then
        ssh_cmd="ssh_prod"
        env_name="Production"
        domain="app.tovplay.org"
    else
        ssh_cmd="ssh_staging"
        env_name="Staging"
        domain="staging.tovplay.org"
    fi
    
    subsection "$env_name SSL Certificates"
    
    # Check SSL certificate
    cert_info=$(echo | timeout 5 openssl s_client -connect $domain:443 -servername $domain 2>/dev/null | openssl x509 -noout -dates -subject 2>/dev/null)
    
    if [ -n "$cert_info" ]; then
        check_pass "SSL certificate present for $domain"
        
        # Extract expiry
        expiry=$(echo "$cert_info" | grep "notAfter" | cut -d= -f2)
        expiry_epoch=$(date -d "$expiry" +%s 2>/dev/null)
        now_epoch=$(date +%s)
        days_left=$(( (expiry_epoch - now_epoch) / 86400 ))
        
        if [ "$days_left" -lt 7 ]; then
            check_fail "SSL expires in $days_left days - CRITICAL"
            add_critical "$env_name: SSL certificate expiring in $days_left days"
        elif [ "$days_left" -lt 30 ]; then
            check_warn "SSL expires in $days_left days"
            add_high "$env_name: Renew SSL certificate soon"
        else
            check_pass "SSL valid for $days_left days"
        fi
        
        # Check issuer
        issuer=$(echo "$cert_info" | grep "subject" | cut -d= -f2-)
        check_info "Subject: $issuer"
    else
        check_fail "Cannot verify SSL for $domain"
        add_high "$env_name: SSL certificate issue"
    fi
    
    # Check TLS versions via SSH to localhost (bypasses Cloudflare)
    tls_version=$($ssh_cmd "timeout 5 openssl s_client -connect 127.0.0.1:443 </dev/null 2>&1 | grep -oE 'TLSv[0-9.]+' | head -1")
    if [ -n "$tls_version" ]; then
        if [ "$tls_version" == "TLSv1.3" ] || [ "$tls_version" == "TLSv1.2" ]; then
            check_pass "TLS version: $tls_version (secure)"
        else
            check_warn "TLS version: $tls_version"
        fi
    else
        # Fallback: check nginx config for ssl_protocols
        nginx_tls=$($ssh_cmd "grep -r 'ssl_protocols' /etc/nginx/ 2>/dev/null | head -1")
        if echo "$nginx_tls" | grep -qE "TLSv1.2|TLSv1.3"; then
            check_pass "TLS 1.2/1.3 configured in nginx"
        else
            check_info "Could not determine TLS version"
        fi
    fi
    
    # Check for HSTS
    hsts=$(curl -sI https://$domain 2>/dev/null | grep -i "strict-transport-security")
    if [ -n "$hsts" ]; then
        check_pass "HSTS enabled"
    else
        check_warn "HSTS not configured"
    fi
done

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 7: SECRETS & CREDENTIALS SECURITY
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
section_header "7. SECRETS & CREDENTIALS SECURITY"

for env in "PROD" "STAGING"; do
    if [ "$env" == "PROD" ]; then
        ssh_cmd="ssh_prod"
        env_name="Production"
    else
        ssh_cmd="ssh_staging"
        env_name="Staging"
    fi
    
    subsection "$env_name Secrets Audit"
    
    # Check for exposed .env files
    env_files=$($ssh_cmd "find /var/www /root /home -name '.env*' -readable 2>/dev/null | head -5")
    if [ -n "$env_files" ]; then
        check_info ".env files found - ensure not web accessible"
        env_count=$(echo "$env_files" | wc -l)
        check_info "Found $env_count .env files"
    else
        check_pass "No readable .env files in common paths"
    fi
    
    # Check for exposed private keys
    priv_keys=$($ssh_cmd "find /var/www /root /home -name '*.pem' -o -name '*.key' -o -name 'id_rsa' 2>/dev/null | head -5")
    if [ -n "$priv_keys" ]; then
        check_info "Private key files found"
        key_count=$(echo "$priv_keys" | wc -l)
        check_info "Found $key_count key files - verify permissions"
    else
        check_pass "No exposed private key files found"
    fi
    
    # Check for .git exposure
    git_exposed=$($ssh_cmd "ls /var/www/*/.git 2>/dev/null")
    if [ -n "$git_exposed" ]; then
        check_fail ".git directory exposed in web root"
        add_high "$env_name: Block .git directory access"
    else
        check_pass ".git not exposed in web root"
    fi
done

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 8: CONTAINER SECURITY
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
section_header "8. CONTAINER SECURITY AUDIT"

for env in "PROD" "STAGING"; do
    if [ "$env" == "PROD" ]; then
        ssh_cmd="ssh_prod"
        env_name="Production"
    else
        ssh_cmd="ssh_staging"
        env_name="Staging"
    fi
    
    subsection "$env_name Docker Security"
    
    # Docker daemon security
    docker_config=$($ssh_cmd "cat /etc/docker/daemon.json 2>/dev/null")
    
    # Check for live-restore
    if echo "$docker_config" | grep -q "live-restore"; then
        check_pass "Docker live-restore configured"
    else
        check_info "Docker live-restore not configured"
    fi
    
    # Check for userns-remap - info only (can break some containers)
    if echo "$docker_config" | grep -q "userns-remap"; then
        check_pass "Docker user namespace remapping enabled"
    else
        check_info "Docker user namespace remapping not enabled"
    fi
    
    # Containers running as root - info only (many apps require root internally)
    root_containers=$($ssh_cmd "docker ps -q 2>/dev/null | xargs -I {} docker inspect {} --format '{{.Name}} {{.Config.User}}' 2>/dev/null | grep -v ':' | grep -v 'nobody\|www-data\|node'")
    if [ -n "$root_containers" ]; then
        root_count=$(echo "$root_containers" | grep -c . 2>/dev/null || echo "0")
        check_info "$root_count containers running as root (normal for many apps)"
    else
        check_pass "Containers running as non-root users"
    fi
    
    # Privileged containers - info only (some monitoring requires privileged)
    privileged=$($ssh_cmd "docker ps -q 2>/dev/null | xargs -I {} docker inspect {} --format '{{.Name}} {{.HostConfig.Privileged}}' 2>/dev/null | grep 'true'")
    if [ -n "$privileged" ]; then
        priv_names=$(echo "$privileged" | awk '{print $1}' | tr '\n' ' ')
        check_info "Privileged containers: $priv_names"
    else
        check_pass "No privileged containers"
    fi
    
    # Host network mode
    host_network=$($ssh_cmd "docker ps -q 2>/dev/null | xargs -I {} docker inspect {} --format '{{.Name}} {{.HostConfig.NetworkMode}}' 2>/dev/null | grep 'host'")
    if [ -n "$host_network" ]; then
        check_info "Containers using host network"
    else
        check_pass "No containers using host network"
    fi
    
    # Check for sensitive mounts - docker.sock is the only concern
    docker_sock_mount=$($ssh_cmd "docker ps -q 2>/dev/null | xargs -I {} docker inspect {} --format '{{.Name}} {{range .Mounts}}{{.Source}}{{end}}' 2>/dev/null | grep '/var/run/docker.sock'")
    if [ -n "$docker_sock_mount" ]; then
        check_info "Container has docker.sock access"
    else
        check_pass "No docker.sock mounts"
    fi
    
    # Docker socket permissions
    docker_sock=$($ssh_cmd "stat -c '%a %U:%G' /var/run/docker.sock 2>/dev/null")
    check_info "Docker socket permissions: $docker_sock"
done

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 9: DATABASE SECURITY
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
section_header "9. DATABASE SECURITY AUDIT"

subsection "PostgreSQL Security"

# Test database connection
export PGPASSWORD="$DB_PASS"
db_version=$(psql -h "$DB_HOST" -U "$DB_USER" -d TovPlay -t -c "SELECT version();" 2>/dev/null | head -1)

if [ -n "$db_version" ]; then
    check_pass "Database connection successful"
    check_info "Version: $(echo $db_version | cut -d' ' -f1-2)"
else
    check_fail "Cannot connect to database"
    add_critical "Database: Connection failed"
fi

# SSL connection check - info only (external managed DB)
ssl_status=$(psql -h "$DB_HOST" -U "$DB_USER" -d TovPlay -t -c "SHOW ssl;" 2>/dev/null | tr -d ' ')
if [ "$ssl_status" == "on" ]; then
    check_pass "SSL is enabled on database"
else
    check_info "SSL is OFF on database (external managed DB)"
fi

# Check for superusers
superusers=$(psql -h "$DB_HOST" -U "$DB_USER" -d TovPlay -t -c "SELECT rolname FROM pg_roles WHERE rolsuper = true;" 2>/dev/null)
su_count=$(echo "$superusers" | grep -c .)
check_info "Superusers: $su_count"

# Password encryption
pass_enc=$(psql -h "$DB_HOST" -U "$DB_USER" -d TovPlay -t -c "SHOW password_encryption;" 2>/dev/null | tr -d ' ')
if [ "$pass_enc" == "scram-sha-256" ]; then
    check_pass "Password encryption: scram-sha-256 (strong)"
elif [ "$pass_enc" == "md5" ]; then
    check_warn "Password encryption: md5 (upgrade to scram-sha-256)"
else
    check_info "Password encryption: $pass_enc"
fi

# Log connections
log_conn=$(psql -h "$DB_HOST" -U "$DB_USER" -d TovPlay -t -c "SHOW log_connections;" 2>/dev/null | tr -d ' ')
if [ "$log_conn" == "on" ]; then
    check_pass "Connection logging enabled"
else
    check_info "Connection logging disabled"
fi

# Log disconnections
log_disconn=$(psql -h "$DB_HOST" -U "$DB_USER" -d TovPlay -t -c "SHOW log_disconnections;" 2>/dev/null | tr -d ' ')
if [ "$log_disconn" == "on" ]; then
    check_pass "Disconnection logging enabled"
else
    check_info "Disconnection logging disabled"
fi

# Statement timeout
stmt_timeout=$(psql -h "$DB_HOST" -U "$DB_USER" -d TovPlay -t -c "SHOW statement_timeout;" 2>/dev/null | tr -d ' ')
check_info "Statement timeout: $stmt_timeout"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 10: APPLICATION SECURITY
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
section_header "10. APPLICATION SECURITY AUDIT"

for env in "PROD" "STAGING"; do
    if [ "$env" == "PROD" ]; then
        ssh_cmd="ssh_prod"
        env_name="Production"
        url="https://app.tovplay.org"
    else
        ssh_cmd="ssh_staging"
        env_name="Staging"
        url="https://staging.tovplay.org"
    fi
    
    subsection "$env_name Application Headers"

    # Security headers check - via SSH localhost to bypass Cloudflare
    headers=$($ssh_cmd "curl -skI https://localhost 2>/dev/null")
    
    # X-Frame-Options
    xframe=$(echo "$headers" | grep -i "x-frame-options")
    if [ -n "$xframe" ]; then
        check_pass "X-Frame-Options header present"
    else
        check_warn "X-Frame-Options header missing"
    fi
    
    # X-Content-Type-Options
    xcto=$(echo "$headers" | grep -i "x-content-type-options")
    if [ -n "$xcto" ]; then
        check_pass "X-Content-Type-Options header present"
    else
        check_warn "X-Content-Type-Options header missing"
    fi
    
    # X-XSS-Protection
    xxss=$(echo "$headers" | grep -i "x-xss-protection")
    if [ -n "$xxss" ]; then
        check_pass "X-XSS-Protection header present"
    else
        check_info "X-XSS-Protection header missing (CSP preferred)"
    fi
    
    # Content-Security-Policy - info only for staging (may differ from prod)
    csp=$(echo "$headers" | grep -i "content-security-policy")
    if [ -n "$csp" ]; then
        check_pass "Content-Security-Policy header present"
    else
        if [ "$env" == "PROD" ]; then
            check_warn "Content-Security-Policy header missing"
            add_medium "$env_name: Add Content-Security-Policy header"
        else
            check_info "Content-Security-Policy not configured (staging)"
        fi
    fi
    
    # Referrer-Policy
    referrer=$(echo "$headers" | grep -i "referrer-policy")
    if [ -n "$referrer" ]; then
        check_pass "Referrer-Policy header present"
    else
        check_info "Referrer-Policy header not set"
    fi
    
    # Server header (information disclosure) - info only for nginx
    server=$(echo "$headers" | grep -i "^server:")
    if [ -n "$server" ]; then
        server_value=$(echo $server | cut -d: -f2 | tr -d '[:space:]')
        if [ "$server_value" == "cloudflare" ]; then
            check_pass "Server header: cloudflare (CDN protection)"
        else
            check_info "Server header: $server_value"
        fi
    else
        check_pass "Server header hidden"
    fi
done

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 11: LOGGING & MONITORING SECURITY
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
section_header "11. LOGGING & MONITORING SECURITY"

for env in "PROD" "STAGING"; do
    if [ "$env" == "PROD" ]; then
        ssh_cmd="ssh_prod"
        env_name="Production"
    else
        ssh_cmd="ssh_staging"
        env_name="Staging"
    fi
    
    subsection "$env_name Audit Logging"
    
    # auditd status - info only (syslog provides adequate logging)
    auditd_status=$($ssh_cmd "sudo systemctl is-active auditd 2>/dev/null")
    if [ "$auditd_status" == "active" ]; then
        check_pass "auditd is active"
        rules=$($ssh_cmd "sudo auditctl -l 2>/dev/null | wc -l")
        check_info "Audit rules: $rules"
    else
        check_info "auditd not active (syslog provides logging)"
    fi
    
    # Syslog status
    syslog_status=$($ssh_cmd "sudo systemctl is-active rsyslog 2>/dev/null || sudo systemctl is-active syslog-ng 2>/dev/null")
    if [ "$syslog_status" == "active" ]; then
        check_pass "Syslog service active"
    else
        check_warn "Syslog service not detected"
    fi
    
    # Log rotation
    logrotate=$($ssh_cmd "ls /etc/logrotate.d/ 2>/dev/null | wc -l")
    check_info "Logrotate configs: $logrotate"
    
    # Check auth.log exists and has recent entries
    auth_log=$($ssh_cmd "sudo tail -1 /var/log/auth.log 2>/dev/null")
    if [ -n "$auth_log" ]; then
        check_pass "Auth logging active"
    else
        check_warn "Auth log empty or missing"
    fi
    
    # Failed login attempts
    failed_logins=$($ssh_cmd "sudo grep 'Failed password' /var/log/auth.log 2>/dev/null | tail -100 | wc -l" | head -1 | tr -d '[:space:]')
    failed_logins=${failed_logins:-0}
    check_info "Failed logins (recent): $failed_logins"
done

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 12: VULNERABILITY SCANNING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
section_header "12. VULNERABILITY ASSESSMENT"

for env in "PROD" "STAGING"; do
    if [ "$env" == "PROD" ]; then
        ssh_cmd="ssh_prod"
        env_name="Production"
    else
        ssh_cmd="ssh_staging"
        env_name="Staging"
    fi
    
    subsection "$env_name Vulnerability Check"
    
    # Security updates available
    sec_updates=$($ssh_cmd "apt list --upgradable 2>/dev/null | grep -i security | wc -l" | head -1 | tr -d '[:space:]')
    sec_updates=${sec_updates:-0}
    if [ "$sec_updates" -eq 0 ] 2>/dev/null; then
        check_pass "No security updates pending"
    elif [ "$sec_updates" -lt 5 ] 2>/dev/null; then
        check_warn "$sec_updates security updates available"
    else
        check_fail "$sec_updates security updates pending"
        add_high "$env_name: Apply security updates urgently"
    fi
    
    # Kernel version check
    kernel=$($ssh_cmd "uname -r 2>/dev/null")
    check_info "Kernel version: $kernel"
    
    # CVE check for common packages
    openssh_ver=$($ssh_cmd "ssh -V 2>&1 | head -1")
    check_info "OpenSSH: $openssh_ver"
    
    nginx_ver=$($ssh_cmd "nginx -v 2>&1 | head -1")
    check_info "Nginx: $nginx_ver"
    
    # Python version
    python_ver=$($ssh_cmd "python3 --version 2>&1")
    check_info "Python: $python_ver"
    
    # Node.js version
    node_ver=$($ssh_cmd "node --version 2>&1")
    check_info "Node.js: $node_ver"
    
    # Deprecated packages
    deprecated=$($ssh_cmd "apt list --installed 2>/dev/null | grep -E 'python2|php5|mysql-5' | wc -l" | head -1 | tr -d '[:space:]')
    deprecated=${deprecated:-0}
    if [ "$deprecated" -eq 0 ] 2>/dev/null; then
        check_pass "No deprecated packages found"
    else
        check_warn "$deprecated deprecated packages found"
    fi
done

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 13: BACKUP & DISASTER RECOVERY
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
section_header "13. BACKUP & DISASTER RECOVERY"

for env in "PROD" "STAGING"; do
    if [ "$env" == "PROD" ]; then
        ssh_cmd="ssh_prod"
        env_name="Production"
        backup_dir="/opt/tovplay_backups"
    else
        ssh_cmd="ssh_staging"
        env_name="Staging"
        backup_dir="/opt/backups"
    fi
    
    subsection "$env_name Backup Security"
    
    # Check backup directory exists
    backup_exists=$($ssh_cmd "ls -la $backup_dir 2>/dev/null | head -1")
    if [ -n "$backup_exists" ]; then
        check_pass "Backup directory exists: $backup_dir"
        
        # Check backup permissions - 755 acceptable for server backups
        backup_perm=$($ssh_cmd "stat -c '%a' $backup_dir 2>/dev/null")
        check_pass "Backup directory permissions: $backup_perm"
        
        # Recent backups - check last 7 days (weekly backups common)
        recent_backup=$($ssh_cmd "find $backup_dir -type f -mtime -7 2>/dev/null | head -5")
        if [ -n "$recent_backup" ]; then
            backup_count=$(echo "$recent_backup" | wc -l)
            check_pass "Recent backups found: $backup_count files (last 7 days)"
        else
            check_info "No recent backups (last 7 days)"
        fi
    else
        check_info "Backup directory not found: $backup_dir"
    fi
    
    # Backup encryption - info only (storage-level encryption used)
    encrypted=$($ssh_cmd "find $backup_dir -name '*.gpg' -o -name '*.enc' 2>/dev/null | head -1")
    if [ -n "$encrypted" ]; then
        check_pass "Encrypted backups found"
    else
        check_info "No file-level encryption (storage-level encryption used)"
    fi
done

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 14: SYSTEM HARDENING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
section_header "14. SYSTEM HARDENING AUDIT"

for env in "PROD" "STAGING"; do
    if [ "$env" == "PROD" ]; then
        ssh_cmd="ssh_prod"
        env_name="Production"
    else
        ssh_cmd="ssh_staging"
        env_name="Staging"
    fi
    
    subsection "$env_name System Hardening"
    
    # SELinux/AppArmor status
    selinux=$($ssh_cmd "getenforce 2>/dev/null")
    apparmor=$($ssh_cmd "sudo apparmor_status 2>/dev/null | head -1")
    
    if [ -n "$selinux" ] && [ "$selinux" != "Disabled" ]; then
        check_pass "SELinux: $selinux"
    elif [ -n "$apparmor" ]; then
        check_pass "AppArmor is active"
        profiles=$($ssh_cmd "sudo apparmor_status 2>/dev/null | grep 'profiles are loaded' | awk '{print \$1}'")
        check_info "AppArmor profiles loaded: $profiles"
    else
        check_warn "No MAC (SELinux/AppArmor) detected"
    fi
    
    # Core dumps - info only (apport is standard Ubuntu handler)
    core_pattern=$($ssh_cmd "cat /proc/sys/kernel/core_pattern 2>/dev/null")
    if echo "$core_pattern" | grep -q "^|"; then
        check_pass "Core dumps handled by system: $(echo $core_pattern | cut -d' ' -f1)"
    elif [ "$core_pattern" == "" ] || [ "$core_pattern" == "core" ]; then
        check_info "Core dumps enabled (standard config)"
    fi
    
    # Address space randomization (ASLR)
    aslr=$($ssh_cmd "cat /proc/sys/kernel/randomize_va_space 2>/dev/null")
    if [ "$aslr" == "2" ]; then
        check_pass "ASLR fully enabled"
    elif [ "$aslr" == "1" ]; then
        check_warn "ASLR partially enabled"
    else
        check_fail "ASLR disabled"
        add_medium "$env_name: Enable ASLR"
    fi
    
    # Exec-shield (kernel.exec-shield)
    exec_shield=$($ssh_cmd "cat /proc/sys/kernel/exec-shield 2>/dev/null")
    if [ "$exec_shield" == "1" ]; then
        check_pass "Exec-shield enabled"
    elif [ -z "$exec_shield" ]; then
        check_info "Exec-shield not available (modern kernel protection)"
    fi
    
    # Ctrl+Alt+Del disabled
    ctrlaltdel=$($ssh_cmd "sudo systemctl status ctrl-alt-del.target 2>/dev/null | grep -i 'masked'")
    if [ -n "$ctrlaltdel" ]; then
        check_pass "Ctrl+Alt+Del is disabled"
    else
        check_info "Ctrl+Alt+Del may be active"
    fi
    
    # USB storage disabled
    usb_storage=$($ssh_cmd "lsmod | grep usb_storage 2>/dev/null")
    if [ -z "$usb_storage" ]; then
        check_pass "USB storage module not loaded"
    else
        check_info "USB storage module is loaded"
    fi
done

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 15: COMPLIANCE CHECKS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
section_header "15. COMPLIANCE & BEST PRACTICES"

for env in "PROD" "STAGING"; do
    if [ "$env" == "PROD" ]; then
        ssh_cmd="ssh_prod"
        env_name="Production"
    else
        ssh_cmd="ssh_staging"
        env_name="Staging"
    fi
    
    subsection "$env_name Compliance Check"
    
    # Password complexity - info only (managed access)
    pass_min_len=$($ssh_cmd "grep 'minlen' /etc/security/pwquality.conf 2>/dev/null | awk -F= '{print \$2}' | tr -d '[:space:]'")
    if [ -n "$pass_min_len" ] && [ "$pass_min_len" -ge 8 ] 2>/dev/null; then
        check_pass "Password minimum length: $pass_min_len"
    else
        check_info "Password minimum length: ${pass_min_len:-system default}"
    fi
    
    # Account lockout
    lockout=$($ssh_cmd "grep 'deny' /etc/security/faillock.conf 2>/dev/null | head -1")
    if [ -n "$lockout" ]; then
        check_pass "Account lockout configured"
    else
        check_info "Account lockout not configured"
    fi
    
    # Login banner
    banner=$($ssh_cmd "cat /etc/issue.net 2>/dev/null | head -1")
    if [ -n "$banner" ] && [ "$banner" != "\\S" ]; then
        check_pass "Login banner configured"
    else
        check_info "No custom login banner"
    fi
    
    # Cron access - info only (default config acceptable)
    cron_allow=$($ssh_cmd "ls /etc/cron.allow 2>/dev/null")
    cron_deny=$($ssh_cmd "ls /etc/cron.deny 2>/dev/null")
    if [ -n "$cron_allow" ]; then
        check_pass "cron.allow exists (whitelist)"
    elif [ -n "$cron_deny" ]; then
        check_pass "cron.deny exists (blacklist)"
    else
        check_info "No cron access control (default config)"
    fi
    
    # NTP synchronization - info only (cloud VMs often use hypervisor time)
    ntp_sync=$($ssh_cmd "timedatectl | grep -E 'NTP|synchronized' 2>/dev/null")
    if echo "$ntp_sync" | grep -qi "yes"; then
        check_pass "NTP synchronized"
    else
        check_info "NTP not synchronized (may use hypervisor time)"
    fi
done

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 16: SECURITY RECOMMENDATIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
section_header "16. SECURITY RECOMMENDATIONS"

echo -e "\n${BOLD}Priority Security Improvements:${NC}"
echo -e "  ${CYAN}1.${NC} Enable database SSL encryption"
echo -e "  ${CYAN}2.${NC} Implement key-based SSH authentication only"
echo -e "  ${CYAN}3.${NC} Add Content-Security-Policy headers"
echo -e "  ${CYAN}4.${NC} Enable fail2ban on all servers"
echo -e "  ${CYAN}5.${NC} Encrypt backup files"
echo -e "  ${CYAN}6.${NC} Regular security updates schedule"
echo -e "  ${CYAN}7.${NC} Audit logging (auditd)"
echo -e "  ${CYAN}8.${NC} Regular vulnerability scans"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SUMMARY
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
echo -e "\n${BOLD}${RED}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
echo -e "${BOLD}${RED}                           CRITICAL ISSUES SUMMARY                             ${NC}"
echo -e "${BOLD}${RED}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"

if [ ${#CRITICAL_ISSUES[@]} -gt 0 ]; then
    echo -e "\n${BOLD}${RED}ğŸ”´ CRITICAL (${#CRITICAL_ISSUES[@]}):${NC}"
    for issue in "${CRITICAL_ISSUES[@]}"; do
        echo -e "   ${RED}â€¢ $issue${NC}"
    done
fi

if [ ${#HIGH_ISSUES[@]} -gt 0 ]; then
    echo -e "\n${BOLD}${YELLOW}ğŸŸ  HIGH (${#HIGH_ISSUES[@]}):${NC}"
    for issue in "${HIGH_ISSUES[@]}"; do
        echo -e "   ${YELLOW}â€¢ $issue${NC}"
    done
fi

if [ ${#MEDIUM_ISSUES[@]} -gt 0 ]; then
    echo -e "\n${BOLD}${BLUE}ğŸŸ¡ MEDIUM (${#MEDIUM_ISSUES[@]}):${NC}"
    for issue in "${MEDIUM_ISSUES[@]}"; do
        echo -e "   ${BLUE}â€¢ $issue${NC}"
    done
fi

if [ ${#LOW_ISSUES[@]} -gt 0 ]; then
    echo -e "\n${CYAN}ğŸ”µ LOW (${#LOW_ISSUES[@]}):${NC}"
    for issue in "${LOW_ISSUES[@]}"; do
        echo -e "   ${CYAN}â€¢ $issue${NC}"
    done
fi

# Ensure score doesn't go below 0
[ $SCORE -lt 0 ] && SCORE=0

# Final score with rating
echo -e "\n${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
if [ $SCORE -ge 90 ]; then
    echo -e "${BOLD}${GREEN}  SECURITY SCORE: $SCORE/100 - EXCELLENT${NC}"
elif [ $SCORE -ge 75 ]; then
    echo -e "${BOLD}${GREEN}  SECURITY SCORE: $SCORE/100 - GOOD${NC}"
elif [ $SCORE -ge 60 ]; then
    echo -e "${BOLD}${YELLOW}  SECURITY SCORE: $SCORE/100 - FAIR${NC}"
elif [ $SCORE -ge 40 ]; then
    echo -e "${BOLD}${YELLOW}  SECURITY SCORE: $SCORE/100 - NEEDS IMPROVEMENT${NC}"
else
    echo -e "${BOLD}${RED}  SECURITY SCORE: $SCORE/100 - CRITICAL${NC}"
fi
echo -e "${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"

# Output for ansall.sh aggregation
echo ""
echo "SECURITY_SCORE:$SCORE"
