HOW TO USE: COMPLETE GITOPS IMPLEMENTATION WITH ARGOCD
========================================================

TABLE OF CONTENTS:
1. Prerequisites Setup
2. ArgoCD Installation
3. Initial Configuration
4. Creating Your First Application
5. Working With Staging/Production
6. Monitoring & Troubleshooting
7. Security & RBAC Management
8. Backup & Disaster Recovery
9. Daily Operations Guide
10. Advanced Operations


========================================================
1. PREREQUISITES SETUP
========================================================

Step 1: Install Required Tools
- Install kubectl (Kubernetes CLI)
  curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
  sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl

- Install ArgoCD CLI
  curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
  chmod +x /usr/local/bin/argocd

- Ensure you have access to a Kubernetes cluster (Minikube, Kind, EKS, GKE, AKS, etc.)

Step 2: Verify Setup
  kubectl cluster-info
  kubectl get nodes

Step 3: Navigate to project directory
  cd /root/gitops

========================================================
2. ARGOCD INSTALLATION
========================================================

Step 1: Create the argocd namespace
  kubectl create namespace argocd

Step 2: Apply production-grade ArgoCD manifests
  kubectl apply -f argocd/production-ha-install.yaml
  kubectl apply -f argocd/production-services.yaml
  kubectl apply -f argocd/production-config.yaml
  kubectl apply -f argocd/production-security.yaml

Step 3: Wait for all pods to be running
  kubectl get pods -n argocd -w

Step 4: Get the ArgoCD server external IP
  kubectl get svc argocd-server -n argocd

Step 5: Get the initial admin password
  kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d

Step 6: Access the ArgoCD UI
  - If using LoadBalancer service: Open https://<EXTERNAL-IP>
  - If using NodePort: Open https://<NODE-IP>:<NODEPORT>
  - If using port-forward: Run `kubectl port-forward svc/argocd-server -n argocd 8080:443` then open https://localhost:8080

Step 7: Login with username "admin" and the password from Step 5

========================================================
3. INITIAL CONFIGURATION
========================================================

Step 1: Setup Git Repository Access
  - If using GitHub: argocd repo add https://github.com/your-username/your-repo --username your-username --password your-personal-access-token
  - If using GitLab: argocd repo add https://gitlab.com/your-username/your-repo --username your-username --password your-access-token
  - For private repositories with SSH keys: argocd repo add git@github.com:your-username/your-repo --ssh-private-key-path ~/.ssh/id_rsa

Step 2: Create your first project
  argocd proj create my-project --dest-server https://kubernetes.default.svc --dest-namespace default

Step 3: Add source repository to your project
  argocd proj add-source my-project https://github.com/your-username/your-repo

Step 4: Add destination to your project
  argocd proj add-destination my-project https://kubernetes.default.svc default

========================================================
4. CREATING YOUR FIRST APPLICATION
========================================================

Step 1: Prepare your application manifests
  - Create a Git repository with Kubernetes manifests
  - Example structure: https://github.com/argoproj/argocd-example-apps
  - Ensure your manifests are in a dedicated folder in the repo

Step 2: Create application via CLI
  argocd app create guestbook \
    --repo https://github.com/argoproj/argocd-example-apps.git \
    --path guestbook \
    --dest-server https://kubernetes.default.svc \
    --dest-namespace default \
    --project default

Step 3: Create application via UI
  - Navigate to ArgoCD UI
  - Click "New App" button
  - Fill in Application Name (e.g., "guestbook")
  - Select Project (default or your custom project)
  - Enter Repository URL
  - Set Revision to HEAD
  - Set Path to the directory containing your manifests
  - Set Cluster URL to "https://kubernetes.default.svc"
  - Set Namespace to "default"
  - Set Sync Policy to "Automatic" to enable GitOps
  - Click "Create"

Step 4: Sync your application
  - In UI: Click "Sync" button on the application
  - OR via CLI: argocd app sync guestbook

Step 5: Verify application is running
  kubectl get pods -n default

========================================================
5. WORKING WITH STAGING/PRODUCTION
========================================================

Step 1: Create separate projects for staging and production
  argocd proj create staging --dest-server https://kubernetes.default.svc --dest-namespace staging
  argocd proj create production --dest-server https://kubernetes.default.svc --dest-namespace production

Step 2: Prepare your Git repository structure for environments
  repository/
  ├── base/                 # Common manifests
  ├── staging/              # Staging-specific configurations  
  ├── production/           # Production-specific configurations
  └── kustomization.yaml    # For Kustomize (if using)

Step 3: Create applications for each environment
  # Staging application
  argocd app create guestbook-staging \
    --repo https://github.com/your-username/your-repo.git \
    --path staging/guestbook \
    --dest-server https://kubernetes.default.svc \
    --dest-namespace staging \
    --project staging \
    --sync-policy automated

  # Production application  
  argocd app create guestbook-production \
    --repo https://github.com/your-username/your-repo.git \
    --path production/guestbook \
    --dest-server https://kubernetes.default.svc \
    --dest-namespace production \
    --project production \
    --sync-policy automated

Step 4: Implement Git branching strategy
  - Use different branches for different environments:
    - development branch → staging app
    - main branch → production app
  - Or use different paths in same repository for each environment

Step 5: Set up approval process for production
  - In production apps, set sync policy to manual instead of automatic
  - This requires manual approval for production deployments

========================================================
6. MONITORING & TROUBLESHOOTING
========================================================

Step 1: Deploy the monitoring stack
  kubectl apply -f monitoring/

Step 2: Access Prometheus
  # If using NodePort
  kubectl get svc -n monitoring | grep prometheus
  # Port forward if needed: kubectl port-forward -n monitoring svc/prometheus 9090:9090

Step 3: Access Grafana
  kubectl get svc -n monitoring | grep grafana
  # Port forward: kubectl port-forward -n monitoring svc/grafana 3000:80
  # Login with admin/admin (change password immediately)

Step 4: Import ArgoCD dashboard in Grafana
  - Go to Grafana UI
  - Click "+" then "Import"
  - Import the dashboard from monitoring/grafana-dashboard.yaml
  - Update the dashboard with correct Prometheus data source

Step 5: Check application health
  argocd app list

Step 6: Troubleshoot OutOfSync applications
  argocd app get your-app-name
  argocd app diff your-app-name
  argocd app sync your-app-name

Step 7: Troubleshoot Degraded applications
  argocd app get your-app-name --show-resource-info
  kubectl get events -n your-app-namespace
  kubectl logs -n argocd deployment/argocd-application-controller

Step 8: Check ArgoCD component health
  kubectl get pods -n argocd
  kubectl logs -n argocd deployment/argocd-application-controller
  kubectl logs -n argocd deployment/argocd-server
  kubectl logs -n argocd deployment/argocd-repo-server

========================================================
7. SECURITY & RBAC MANAGEMENT
========================================================

Step 1: Understand the RBAC configuration
  - Check /root/gitops/argocd/production-config.yaml for RBAC settings
  - Review the policy.csv in argocd-rbac-cm ConfigMap

Step 2: Create custom roles
  # Create a ConfigMap for custom RBAC
  kubectl create configmap custom-rbac \
    --from-literal=argocd-rbac-cm.yaml \
    --dry-run=client -o yaml | kubectl apply -f -

Step 3: Add team members to roles
  # In your argocd-rbac-cm ConfigMap, add group mappings:
  # g, dev-team, role:readonly
  # g, ops-team, role:admin

Step 4: Configure authentication (if needed)
  # For Dex integration, configure in argocd-dex-server deployment
  # For external auth, use argocd-cmd-params-cm to configure external providers

Step 5: Rotate admin password
  argocd account update-password

Step 6: Create application-specific accounts
  # Create a local user account for automated systems
  argocd account create my-service-account --account-type service

========================================================
8. BACKUP & DISASTER RECOVERY
========================================================

Step 1: Review the backup configuration
  cat argocd/backup-and-dr.yaml
  Notice the CronJob that creates daily backups

Step 2: Customize the backup configuration
  # Modify the backup CronJob to use your storage solution
  # For S3: Uncomment and configure the AWS S3 upload line
  # For other storage: Replace with appropriate upload command

Step 3: Deploy backup system
  kubectl apply -f argocd/backup-and-dr.yaml

Step 4: Monitor backup jobs
  kubectl get jobs -n argocd
  kubectl get cronjobs -n argocd

Step 5: Test disaster recovery
  - In a test environment, simulate a disaster:
  - Delete the argocd namespace: kubectl delete namespace argocd
  - Restore using the disaster recovery documentation in backup-and-dr.yaml
  - Apply the installation manifests again
  - Restore application definitions from the backup

Step 6: Verify recovery
  - Check that ArgoCD components are running
  - Verify applications are syncing correctly
  - Confirm all configurations match the backup

========================================================
9. DAILY OPERATIONS GUIDE
========================================================

Step 1: Morning routine - Check application status
  argocd app list --query 'status.health.status!=Healthy' --output yaml
  argocd app list --query 'status.sync.status!=Synced' --output yaml

Step 2: Check ArgoCD component health
  kubectl get pods -n argocd

Step 3: Review recent events
  kubectl get events -n argocd --sort-by='.lastTimestamp'

Step 4: Monitor alerts
  # Check Alertmanager UI or your notification channels
  # Look for any critical alerts generated overnight

Step 5: Handle any out-of-sync applications
  # For each out-of-sync app, determine if the change is intentional
  # If intentional, sync: argocd app sync app-name
  # If not intentional, investigate and remediate

Step 6: Review and approve any pending syncs for production apps
  argocd app list --project production
  # For manual sync policy apps, review and sync as appropriate

Step 7: Check security logs
  # Review access logs if configured
  # Check for any unauthorized access attempts

Step 8: End of day - Verify everything is healthy
  argocd app list
  kubectl get pods -n argocd

========================================================
10. ADVANCED OPERATIONS
========================================================

Step 1: Using ApplicationSets for bulk operations
  # Create an ApplicationSet manifest for multiple applications
  apiVersion: argoproj.io/v1alpha1
  kind: ApplicationSet
  metadata:
    name: guestbook-set
    namespace: argocd
  spec:
    generators:
    - list:
        elements:
        - cluster: engineering-dev
          url: https://1.2.3.4
          destination: dev
        - cluster: engineering-prod
          url: https://5.6.7.8
          destination: prod
    template:
      metadata:
        name: '{{cluster}}-guestbook'
      spec:
        project: default
        source:
          repoURL: https://github.com/argoproj/argocd-example-apps
          targetRevision: HEAD
          path: guestbook
        destination:
          server: '{{url}}'
          namespace: '{{destination}}'
        syncPolicy:
          automated:
            prune: true
            selfHeal: true

Step 2: Implementing policy-based automation
  # Use the notification system to send alerts
  # Configure webhooks for CI/CD integration
  # Set up automated promotion between environments

Step 3: Scaling ArgoCD for large installations
  # Increase replica counts for high-traffic installations
  # Tune resource limits based on application count
  # Monitor resource usage and scale accordingly

Step 4: Integrating with CI/CD
  # Configure your CI system to update Git when code changes
  # Set up webhooks from Git provider to trigger ArgoCD refresh
  # Use ArgoCD CLI in CI pipeline for validation

Step 5: Performance optimization
  # Adjust appResyncPeriod based on your needs (default is 180s)
  # Configure resource exclusions to improve performance
  # Tune parallelization settings for large applications

Step 6: Multi-cluster management
  # Register additional clusters with argocd cluster add
  # Create applications that target different clusters
  # Use cluster-specific configurations in your Git repo

========================================================
END OF INSTRUCTIONS
========================================================

TIPS FOR DEVOPS SUCCESS:
- Always test in staging before production
- Keep your Git repositories organized and clean
- Monitor resource usage and scale as needed
- Regularly update ArgoCD to get security patches
- Document any custom configurations you make
- Practice disaster recovery procedures regularly
- Create proper alerts for critical issues
- Use Git branching strategies that match your release process